<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ELDROW</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link rel="stylesheet" href="styles.css">
  <script async defer src="https://buttons.github.io/buttons.js"></script>
</head>
<body>
  <div class="game-container" style="position: relative;">
    <h1><i class="fas fa-gamepad"></i> ELDROW</h1>
    
    <a href="https://github.com/shnukrw/eldrow" class="github-corner" aria-label="View source on GitHub">
      <svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0; border-top-right-radius: 15px;" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="m128.3,109c-14.5-9.3-9.3-19.4-9.3-19.4c3-6.9,1.5-11,1.5-11c-1.3-6.6,2.9-2.3,2.9-2.3c3.9,4.6,2.1,11,2.1,11c-2.6,10.3,5.1,14.6,8.9,15.9" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115,115 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
      </svg>
    </a>

    <div class="home-stats" id="home-stats">
      <div>High Score: <span id="high-score">0</span></div>
    </div>

    <div class="game-stats" id="game-stats" style="display: none;">
      <div class="stats-row survival-stats" id="survival-stats">
        <div id="hearts-display"></div>
        <div class="level-display" id="level-display">level <span id="level-number">1</span></div>
        <div><i class="fas fa-star"></i> <span id="score">0</span></div>
      </div>
      <div class="stats-row daily-stats" id="daily-stats" style="display: none;">
        <div id="aims-display"></div>
      </div>
    </div>

    <div id="game-area">
      <div id="start-screen">
        <p id="game-description">Listen to the reversed word and guess the original!</p>


        <div class="start-section">
          <button class="start-button" onclick="startGame()">Start</button>
          <div class="language-selector">
            <button class="current-lang-btn" id="current-lang" onclick="toggleLanguagePopup()">EN</button>
            <div class="language-popup" id="language-popup">
              <button class="lang-option" data-lang="english" onclick="selectLanguageFromPopup('english')">EN</button>
              <button class="lang-option" data-lang="russian" onclick="selectLanguageFromPopup('russian')">RU</button>
              <button class="lang-option" data-lang="german" onclick="selectLanguageFromPopup('german')">DE</button>
              <button class="lang-option" data-lang="spanish" onclick="selectLanguageFromPopup('spanish')">ES</button>
            </div>
          </div>
        </div>
      </div>

      <div id="play-screen" style="display: none;">
        <!-- Timer above word -->
        <div class="timer-container" style="text-align: center; margin-bottom: 15px;">
          <div class="timer large-timer" id="timer" style="display: none;"><i class="fas fa-stopwatch"></i><span id="timer-value">60</span></div>
          <div class="timer large-timer" id="daily-timer" style="display: none;"><i class="fas fa-clock"></i><span id="daily-timer-value">0:00</span></div>
        </div>

        <div style="margin-bottom: 20px; max-width: 500px; margin-left: auto; margin-right: auto; position: relative;">
          <div class="word-display" id="word-display" onclick="refocusInput()"></div>
          <input type="text" class="hidden-input" id="hidden-input" autocomplete="off" spellcheck="false"
                 onkeypress="handleKeyPress(event)" oninput="handleInput(event)"
                 onblur="refocusInput()">
        </div>

        <div style="display: flex; gap: 15px; margin-bottom: 20px; max-width: 500px; margin-left: auto; margin-right: auto; align-items: stretch; position: relative;">
          <button class="skip-button" onclick="skipWord(); refocusInput()" style="flex: 1;" id="skip-btn">Skip</button>
          <button class="play-button speaker-btn" id="play-btn" onclick="playReversedWord(); refocusInput()"><i class="fas fa-volume-up"></i></button>
          <button class="submit-button" onclick="submitGuess(); refocusInput()" style="flex: 1;" id="submit-btn">Submit</button>
          <div id="points-animation-container" style="position: absolute; pointer-events: none; width: 100%; height: 100%;"></div>
        </div>

        <div class="feedback" id="feedback"></div>
      </div>

      <div id="game-over-screen" style="display: none;" class="game-over">
        <h2>Share my score</h2>
        <p>Last: <i class="fas fa-star"></i> <span id="final-score">0</span></p>
        <p>Best: <i class="fas fa-star"></i> <span id="best-score">0</span></p>

        <div class="share-buttons" style="margin: 10px 0; display: flex; gap: 10px; justify-content: center;">
          <button class="share-btn twitter" onclick="shareToTwitter()">ùïè</button>
          <button class="share-btn whatsapp" onclick="shareToWhatsApp()"><i class="fab fa-whatsapp"></i></button>
          <button class="share-btn telegram" onclick="shareToTelegram()"><i class="fab fa-telegram"></i></button>
          <button class="share-btn copy" onclick="copyScore()" title="Copy score"><i class="fas fa-copy"></i></button>
        </div>

        <button class="start-button" onclick="restartGame()">Play Again</button>
      </div>
    </div>
  </div>

  <script>
    let words = [];
    let voicesCache = [];

    let gameState = {
      score: 0,
      lives: 3,
      level: 1,
      currentWord: "",
      timeLeft: 60,
      timer: null,
      wordsGuessed: 0,
      isPlaying: false,
      currentLanguage: null, // No default language - user must select
      speechLang: null,
      highScore: 0,
      currentGuess: "",
      displayState: "normal", // normal, correct, skipped, timeout
      startGameRequested: false, // Track if user clicked start game but was waiting for language selection
      gameMode: "daily", // "survival" or "daily"
      dailyWords: [],
      currentWordIndex: 0,
      skippedWords: [],
      elapsedTime: 0,
      aims: [], // aims for daily challenge: 'empty', 'hit', 'helped', 'miss'
      dailyResult: {}, // {lang: {date: {hits, time}}}
      survivalResult: {}, // {lang: highScore}
      helpRequested: false, // Track if help was requested for current word
      dailyWordStats: [], // Track detailed stats for each word: {word, status: 'correct'|'helped'|'skipped', time}
      processedWords: 0 // Track total words processed (including skipped ones)
    };

    function isSupported() {
      return 'speechSynthesis' in window && 'SpeechSynthesisUtterance' in window;
    }

    // Short silent utterance to wake up the speech engine on iOS/Safari/Chrome
    function primeSynthOnce() {
      return new Promise(resolve => {
        try {
          const synth = window.speechSynthesis;
          synth.cancel(); // sometimes helps with Safari
          const u = new SpeechSynthesisUtterance(' ');
          u.rate = 10;
          u.volume = 0;  // may be ignored, but utterance is very short
          u.onend = resolve;
          u.onerror = resolve;
          synth.speak(u);
          setTimeout(resolve, 600); // safety timeout
        } catch {
          resolve();
        }
      });
    }

    // Wait for voices to load: event + polling with timeout
    function waitForVoices(timeoutMs = 5000, pollEveryMs = 120) {
      const synth = window.speechSynthesis;
      const start = Date.now();
      return new Promise(resolve => {
        function check() {
          const list = synth.getVoices() || [];
          if (list.length > 0) return resolve(list);
          if (Date.now() - start >= timeoutMs) return resolve(list); // empty - unfortunate
          setTimeout(check, pollEveryMs);
        }
        const onChanged = () => {
          const list = synth.getVoices() || [];
          if (list.length > 0) {
            synth.removeEventListener('voiceschanged', onChanged);
            resolve(list);
          }
        };
        synth.addEventListener('voiceschanged', onChanged);
        synth.getVoices(); // trigger
        check();
      });
    }

    async function initSpeechSynthesis() {
      if (!isSupported()) {
        throw new Error('Speech Synthesis is not supported in this browser.');
      }
      await primeSynthOnce();
      voicesCache = await waitForVoices(5000);
      if (!voicesCache || voicesCache.length === 0) {
        // Often happens in Firefox on Android/some builds without system TTS
        throw new Error('No voices found. Try a different browser (Chrome/Safari/Edge) or enable system TTS.');
      }

      // Debug: Log available voices
      console.log('Available voices:', voicesCache.length);
      voicesCache.forEach((voice, index) => {
        console.log(`Voice ${index}: ${voice.name} (${voice.lang}) - ${voice.localService ? 'local' : 'remote'}`);
      });

      // Check for Russian voices specifically
      const russianVoices = voicesCache.filter(voice =>
        voice.lang.toLowerCase().includes('ru') ||
        voice.lang.toLowerCase().includes('russian')
      );
      console.log('Russian voices found:', russianVoices.length);
      russianVoices.forEach(voice => {
        console.log(`Russian voice: ${voice.name} (${voice.lang})`);
      });

      return true;
    }

    async function loadWords(language) {
      try {
        console.log(`Loading words for language: ${language}`);
        const response = await fetch(`words/${language}.txt`);
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        const text = await response.text();
        words = text.trim().split('\n').filter(word => word.trim().length > 0);
        console.log(`Successfully loaded ${language} words. Total words count:`, words.length);
        console.log(`First 5 words:`, words.slice(0, 5));
        console.log(`Word lengths range: ${Math.min(...words.map(w => w.length))} - ${Math.max(...words.map(w => w.length))}`);
      } catch (error) {
        console.error(`Failed to load ${language} words:`, error);
        // Fallback to basic English words
        words = ["cat", "dog", "run", "sun", "car", "big", "red", "hot", "fun", "hat", "happy", "jumping", "morning", "kitchen", "rainbow", "picture", "adventure", "beautiful", "dangerous", "knowledge", "mysterious"];
        console.log("Using fallback English words");
      }
    }

    async function loadDailyWords(language) {
      try {
        console.log(`Loading daily words for language: ${language}`);
        const response = await fetch(`daily/${language}.json`);
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        const data = await response.json();

        // Get today's date in YYYY-MM-DD format
        const today = new Date().toISOString().split('T')[0];

        if (data[today]) {
          gameState.dailyWords = data[today];
          console.log(`Successfully loaded daily words for ${today}:`, gameState.dailyWords);
        } else {
          throw new Error(`No daily words found for ${today}`);
        }
      } catch (error) {
        console.error(`Failed to load daily words for ${language}:`, error);
        // Fallback to random words from main word list
        if (words.length === 0) {
          await loadWords(language);
        }
        gameState.dailyWords = [];
        for (let i = 0; i < 10; i++) {
          gameState.dailyWords.push(words[Math.floor(Math.random() * words.length)]);
        }
        console.log("Using fallback daily words:", gameState.dailyWords);
      }
    }

    function selectGameMode(mode) {
      gameState.gameMode = mode;

      // Update result display based on new mode
      updateResultDisplay();

      console.log(`Selected game mode: ${mode}`);
    }

    function saveSettings() {
      const settings = {
        language: gameState.currentLanguage,
        highScore: gameState.highScore,
        dailyResult: gameState.dailyResult,
        survivalResult: gameState.survivalResult,
        gameProgress: gameState.gameProgress
      };
      localStorage.setItem('eldrow-settings', JSON.stringify(settings));
    }

    function saveGameProgress() {
      if (gameState.gameMode !== 'daily' || !gameState.isPlaying) return;

      const today = new Date().toISOString().split('T')[0];

      if (!gameState.gameProgress) {
        gameState.gameProgress = {};
      }
      if (!gameState.gameProgress[gameState.currentLanguage]) {
        gameState.gameProgress[gameState.currentLanguage] = {};
      }

      gameState.gameProgress[gameState.currentLanguage][today] = {
        currentWordIndex: gameState.currentWordIndex,
        processedWords: gameState.processedWords,
        aims: [...gameState.aims],
        elapsedTime: gameState.elapsedTime,
        dailyWords: [...gameState.dailyWords],
        skippedWords: [...gameState.skippedWords],
        dailyWordStats: [...gameState.dailyWordStats],
        helpRequested: gameState.helpRequested,
        currentWord: gameState.currentWord,
        currentGuess: gameState.currentGuess,
        displayState: gameState.displayState
      };

      saveSettings();
    }

    function hasUnfinishedGame() {
      if (!gameState.gameProgress || !gameState.currentLanguage) return false;

      const today = new Date().toISOString().split('T')[0];
      const progress = gameState.gameProgress[gameState.currentLanguage];

      if (!progress || !progress[today]) return false;

      // Check if there's already a completed result for today
      const dailyData = gameState.dailyResult[gameState.currentLanguage];
      const todayResult = dailyData && dailyData[today];

      return !todayResult; // Return true only if no completed result exists
    }

    function cleanOldProgress() {
      if (!gameState.gameProgress) return;

      const today = new Date().toISOString().split('T')[0];

      // Clean progress for all languages, keeping only today's progress
      Object.keys(gameState.gameProgress).forEach(language => {
        Object.keys(gameState.gameProgress[language]).forEach(date => {
          if (date !== today) {
            delete gameState.gameProgress[language][date];
          }
        });
      });

      saveSettings();
    }

    async function continueGame() {
      if (gameState.gameMode !== 'daily' || !hasUnfinishedGame()) {
        startGame();
        return;
      }

      const today = new Date().toISOString().split('T')[0];
      const progress = gameState.gameProgress[gameState.currentLanguage][today];

      try {
        // Load words first
        await loadWords(gameState.currentLanguage);

        // Initialize speech synthesis
        await initSpeechSynthesis();

        // Restore game state from saved progress
        gameState.currentWordIndex = progress.currentWordIndex;
        gameState.processedWords = progress.processedWords;
        gameState.aims = [...progress.aims];
        gameState.elapsedTime = progress.elapsedTime;
        gameState.dailyWords = [...progress.dailyWords];
        gameState.skippedWords = [...progress.skippedWords];
        gameState.dailyWordStats = [...progress.dailyWordStats];
        gameState.helpRequested = progress.helpRequested;
        gameState.currentWord = progress.currentWord;
        gameState.currentGuess = progress.currentGuess || '';
        gameState.displayState = progress.displayState || 'normal';
        gameState.isPlaying = true;
        gameState.gameMode = 'daily';

        // Set speech language
        const langCodes = {
          english: 'en-US',
          russian: 'ru-RU',
          german: 'de-DE',
          spanish: 'es-ES'
        };
        gameState.speechLang = langCodes[gameState.currentLanguage];

        // Start the game interface
        document.getElementById("home-stats").style.display = "none";
        document.getElementById("game-stats").style.display = "flex";
        document.getElementById("start-screen").style.display = "none";
        document.getElementById("play-screen").style.display = "block";
        document.getElementById("game-over-screen").style.display = "none";

        // Set up current word display and update UI
        updateDisplay();

        // Initialize word display but preserve restored state
        const wordDisplay = document.getElementById('word-display');

        // Restore input state
        const hiddenInput = document.getElementById('hidden-input');
        if (hiddenInput) {
          hiddenInput.value = gameState.currentGuess;
        }

        // Update word display to show current state (including hints if any)
        console.log('Restored state:', {
          helpRequested: gameState.helpRequested,
          displayState: gameState.displayState,
          currentWord: gameState.currentWord,
          currentGuess: gameState.currentGuess
        });
        updateWordDisplay();

        // Update skip button based on restored help state
        updateSkipButton();

        enableGameButtons();
        document.getElementById("feedback").textContent = "";

        // Start timer for daily mode
        startDailyTimer();

        refocusInput();
      } catch (error) {
        console.error('Failed to continue game:', error);
        startGame(); // Fall back to new game
      }
    }

    function loadSettings() {
      console.log('loadSettings called');
      try {
        const saved = localStorage.getItem('eldrow-settings');
        console.log('Saved settings:', saved);
        if (saved) {
          const settings = JSON.parse(saved);
          console.log('Parsed settings:', settings);
          gameState.currentLanguage = settings.language || null;
          gameState.highScore = settings.highScore || 0;
          gameState.dailyResult = settings.dailyResult || {};
          gameState.survivalResult = settings.survivalResult || {};
          gameState.gameProgress = settings.gameProgress || {};

          // Clean old progress
          cleanOldProgress();

          // Update UI
          updateLanguageDisplay();
          updateDisplay();
        } else {
          // No saved settings - language stays null
          console.log('No saved settings - language is null');
          gameState.currentLanguage = null;
        }
        console.log('After loadSettings - currentLanguage:', gameState.currentLanguage);
      } catch (error) {
        console.error('Failed to load settings:', error);
        gameState.currentLanguage = null; // Ensure no language is set
      }
    }

    function updateLanguageDisplay() {
      const langCodes = {
        english: 'EN',
        russian: 'RU',
        german: 'DE',
        spanish: 'ES'
      };

      // Update current language button - show globe icon if no language selected
      const currentLangBtn = document.getElementById('current-lang');
      if (!gameState.currentLanguage) {
        currentLangBtn.innerHTML = '<i class="fas fa-globe"></i>';
        currentLangBtn.title = 'Select Language';
      } else {
        currentLangBtn.textContent = langCodes[gameState.currentLanguage];
        currentLangBtn.title = `Current Language: ${gameState.currentLanguage}`;
      }

      // Update popup options - only show active if language is selected
      const options = document.querySelectorAll('.lang-option');
      options.forEach(option => {
        if (option.dataset.lang === gameState.currentLanguage && gameState.currentLanguage) {
          option.classList.add('active');
        } else {
          option.classList.remove('active');
        }
      });
    }

    function toggleLanguagePopup() {
      const popup = document.getElementById('language-popup');
      popup.classList.toggle('show');
    }

    async function selectLanguageFromPopup(language) {
      const wasPlaying = gameState.isPlaying;

      gameState.currentLanguage = language;
      await loadWords(gameState.currentLanguage);

      // Set speech language based on selection
      const langCodes = {
        english: 'en-US',
        russian: 'ru-RU',
        german: 'de-DE',
        spanish: 'es-ES'
      };
      gameState.speechLang = langCodes[gameState.currentLanguage];

      updateLanguageDisplay();
      updateResultDisplay();
      saveSettings();

      // Hide popup
      const popup = document.getElementById('language-popup');
      popup.classList.remove('show');
      // Clear the inline display style so CSS can hide it
      popup.style.display = '';

      // If game was playing, start a new word with the new language
      if (wasPlaying) {
        nextWord();
      }

      // If user clicked start game but was waiting for language selection, start the game now
      if (gameState.startGameRequested) {
        console.log('Language selected, automatically starting game as requested');
        gameState.startGameRequested = false; // Reset the flag
        startGame(); // Recursively call startGame now that language is set
      }
    }

    async function selectLanguage(language) {
      // Keep for backward compatibility
      await selectLanguageFromPopup(language);
    }

    function normalizeWord(str) {
      return str.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
    }

    function resetInput() {
      const hiddenInput = document.getElementById('hidden-input');
      gameState.currentGuess = '';
      if (hiddenInput) {
        hiddenInput.value = '';
      }
    }

    function initializeWordDisplay() {
      const wordDisplay = document.getElementById('word-display');

      resetInput();
      // Only reset display state if not continuing a game
      if (!gameState.helpRequested) {
        gameState.displayState = 'normal';
      }
      updateWordDisplay();
    }

    function updateWordDisplay() {
      const wordDisplay = document.getElementById('word-display');
      const wordLength = gameState.currentWord.length;
      const guessLength = gameState.currentGuess.length;

      let displayText = '';

      if (gameState.displayState === 'helped' && gameState.gameMode === 'daily') {
        // Show help hints - first and last letters
        const hintCount = wordLength > 12 ? 2 : 1; // 2 letters for words 12+ chars, 1 for shorter
        for (let i = 0; i < wordLength; i++) {
          if (i < guessLength) {
            displayText += `<span class="letter typed">${gameState.currentGuess[i]}</span>`;
          } else if (i < hintCount || i >= wordLength - hintCount) {
            // Show hint letters
            displayText += `<span class="letter hint">${gameState.currentWord[i]}</span>`;
          } else {
            displayText += `<span class="letter asterisk">*</span>`;
          }
        }
      } else {
        // Normal display - show typed letters and remaining asterisks
        for (let i = 0; i < wordLength; i++) {
          if (i < guessLength) {
            displayText += `<span class="letter typed">${gameState.currentGuess[i]}</span>`;
          } else {
            displayText += `<span class="letter asterisk">*</span>`;
          }
        }
      }

      wordDisplay.innerHTML = displayText;

      // Determine size modifier based on word length
      let sizeModifier = 's';
      if (wordLength >= 25) {
        sizeModifier = 'xl';
      } else if (wordLength >= 18) {
        sizeModifier = 'l';
      } else if (wordLength >= 12) {
        sizeModifier = 'm';
      }

      // Apply state-based styling and size modifier
      wordDisplay.className = `word-display ${gameState.displayState} ${sizeModifier}`;
    }

    function handleInput(event) {
      if (!gameState.isPlaying) return;

      const input = event.target.value;
      const wordLength = gameState.currentWord.length;

      // Only allow Unicode letters and limit to word length
      const filteredInput = input.replace(/[^\p{L}]/gu, '').toLowerCase().slice(0, wordLength);

      // Update the input field with filtered value to keep it in sync
      if (event.target.value !== filteredInput) {
        event.target.value = filteredInput;
      }

      gameState.currentGuess = filteredInput;
      updateWordDisplay();
    }


    async function changeLanguage() {
      // Keep this function for backward compatibility
      await selectLanguageFromPopup(gameState.currentLanguage);
    }

    function showPointsAnimation(buttonId, points) {
      const button = document.getElementById(buttonId);
      const container = document.getElementById('points-animation-container');

      if (!button || !container) return;

      // Get button position relative to container
      const buttonRect = button.getBoundingClientRect();
      const containerRect = container.getBoundingClientRect();

      const relativeX = buttonRect.left - containerRect.left + buttonRect.width / 2;
      const relativeY = buttonRect.top - containerRect.top + buttonRect.height * 0.25;

      // Create popup element
      const popup = document.createElement('div');
      popup.className = `points-popup ${points > 0 ? 'positive' : 'negative'}`;
      popup.textContent = points > 0 ? `+${points}` : `${points}`;
      popup.style.left = relativeX + 'px';
      popup.style.top = relativeY + 'px';
      popup.style.transform = 'translate(-50%, -50%)';

      container.appendChild(popup);

      // Remove element after animation
      setTimeout(() => {
        if (popup.parentNode) {
          popup.parentNode.removeChild(popup);
        }
      }, 2000);
    }

    async function startGame() {
      // Stop next game timer when starting a game
      stopNextGameTimer();

      // Debug logging
      console.log('startGame called');
      console.log('currentLanguage:', gameState.currentLanguage);

      // Check if user needs to select a language
      if (!gameState.currentLanguage) {
        console.log('Opening language popup');
        // Set flag to indicate user wants to start game after language selection
        gameState.startGameRequested = true;

        // Force language selection popup to open
        const popup = document.getElementById('language-popup');
        console.log('Popup element:', popup);
        if (!popup) {
          console.error('Popup element not found!');
          return;
        }

        console.log('Popup current style.display:', popup.style.display);
        console.log('Popup computed display:', window.getComputedStyle(popup).display);
        console.log('Popup classes before:', popup.className);

        popup.classList.add('show');
        // Force display to ensure it's visible
        popup.style.display = 'block';

        console.log('Popup classes after:', popup.className);
        console.log('Popup style.display after:', popup.style.display);
        console.log('Popup computed display after:', window.getComputedStyle(popup).display);

        console.log('Popup should be visible now, game will start after language selection');
        return; // Don't start the game until language is selected
      }

      // Disable start button during initialization
      const startBtn = document.querySelector('.start-button');
      const originalStartText = startBtn.textContent;
      startBtn.disabled = true;
      startBtn.textContent = 'Initializing...';

      try {
        // Initialize speech synthesis first
        await initSpeechSynthesis();

        // Load words based on game mode
        if (gameState.gameMode === "daily") {
          await loadDailyWords(gameState.currentLanguage);
        } else {
          await loadWords(gameState.currentLanguage);
        }

        // Set speech language before resetting gameState
        const langCodes = {
          english: 'en-US',
          russian: 'ru-RU',
          german: 'de-DE',
          spanish: 'es-ES'
        };
        const speechLang = langCodes[gameState.currentLanguage];

        // Reset game state based on mode
        if (gameState.gameMode === "daily") {
          gameState = {
            ...gameState,
            currentWord: "",
            timer: null,
            wordsGuessed: 0,
            isPlaying: true,
            speechLang: speechLang,
            currentWordIndex: 0,
            skippedWords: [],
            elapsedTime: 0,
            aims: Array(gameState.dailyWords.length).fill('empty'),
            helpRequested: false,
            dailyWordStats: [],
            processedWords: 0
          };
        } else {
          gameState = {
            ...gameState,
            score: 0,
            lives: 3,
            level: 1,
            currentWord: "",
            timeLeft: 60,
            timer: null,
            wordsGuessed: 0,
            isPlaying: true,
            speechLang: speechLang,
            helpRequested: false
          };
        }

        // Re-enable submit button when starting new game
        const submitBtn = document.getElementById('submit-btn');
        if (submitBtn) {
          submitBtn.disabled = false;
        }

        // Show game elements, hide home elements
        document.getElementById("home-stats").style.display = "none";
        document.getElementById("game-stats").style.display = "flex";

        updateDisplay();
        document.getElementById("start-screen").style.display = "none";
        document.getElementById("play-screen").style.display = "block";
        document.getElementById("game-over-screen").style.display = "none";

        // Ensure input is clean before starting
        resetInput();

        nextWord();

      } catch (error) {
        // Handle initialization errors
        console.error('Game initialization failed:', error);

        // Show error message
        const errorMsg = error.message || 'Failed to initialize game';
        alert(`Game initialization failed: ${errorMsg}\n\nPlease try:\n‚Ä¢ Using Chrome, Safari, or Edge browser\n‚Ä¢ Enabling system text-to-speech\n‚Ä¢ Refreshing the page`);

        // Re-enable start button
        startBtn.disabled = false;
        startBtn.textContent = originalStartText;
      }
    }

    function nextWord() {
      if (!gameState.isPlaying) return;

      // Reset help state for new word
      gameState.helpRequested = false;

      if (gameState.gameMode === "daily") {
        // Daily challenge mode
        if (gameState.currentWordIndex >= gameState.dailyWords.length) {
          // Add skipped words to the end
          if (gameState.skippedWords.length > 0) {
            const skippedWord = gameState.skippedWords.shift();
            gameState.currentWord = skippedWord;
            console.log(`Selected skipped word: ${gameState.currentWord}`);
          } else {
            // All words completed or processed 10 words
            endDailyChallenge();
            return;
          }
        }

        // Check if we've processed 10 words total
        if (gameState.processedWords >= gameState.dailyWords.length) {
          endDailyChallenge();
          return;
        } else {
          gameState.currentWord = gameState.dailyWords[gameState.currentWordIndex];
          console.log(`Selected daily word ${gameState.currentWordIndex + 1}: ${gameState.currentWord}`);
        }

        updateDisplay();
        startDailyTimer();
      } else {
        // Survival mode
        if (!words || words.length === 0) {
          console.error(`No words available`);
          return;
        }

        // Filter words by length based on level
        const levelUpExtra = (gameState.wordsGuessed % 5 == 4) ? 3 : 0;
        const minLength = (gameState.level + 2) + levelUpExtra;
        const maxLength = (gameState.level + 2) * 2 + levelUpExtra;
        const filteredWords = words.filter(word => word.length >= minLength && word.length <= maxLength);

        // If no words match the criteria, fallback to original list
        const availableWords = filteredWords.length > 0 ? filteredWords : words;

        gameState.currentWord = availableWords[Math.floor(Math.random() * availableWords.length)];
        console.log(`Selected word: ${gameState.currentWord} (${gameState.currentLanguage}, level ${gameState.level}, length ${gameState.currentWord.length}, range: ${minLength}-${maxLength}, available: ${availableWords.length})`);

        updateDisplay();
        startTimer();
      }

      initializeWordDisplay();
      updateSkipButton();
      enableGameButtons();
      document.getElementById("feedback").textContent = "";
      refocusInput();

      // Save progress after each word setup
      if (gameState.gameMode === 'daily') {
        saveGameProgress();
      }

      setTimeout(() => {
        if (gameState.isPlaying) {
          playReversedWord();
        }
      }, 500);
    }

    function playReversedWord() {
      if (buttonsBlocked) return;
      if (!gameState.isPlaying) return;

      const reversedWord = gameState.currentWord.split("").reverse().join("");
      const utterance = new SpeechSynthesisUtterance(reversedWord);
      utterance.rate = 0.80 + 0.025 * gameState.level;
      utterance.pitch = 1;
      utterance.volume = 1;
      utterance.lang = gameState.speechLang || 'en-US';

      // Try to find and set a specific voice for the current language
      if (voicesCache && voicesCache.length > 0) {
        let preferredVoice = null;

        preferredVoice = voicesCache.find(voice =>
          voice.lang.toLowerCase().startsWith(utterance.lang.toLowerCase().substring(0, 2))
        );
        
        if (preferredVoice) {
          utterance.voice = preferredVoice;
          console.log(`Using voice: ${preferredVoice.name} (${preferredVoice.lang}) for word: ${reversedWord}`);
        } else {
          console.log(`No suitable voice found for ${gameState.currentLanguage}, using default voice`);
        }
      }

      // Add error handling for speech synthesis
      utterance.onerror = (event) => {
        console.error('Speech synthesis error:', event.error);
        console.log(`Failed to speak: "${reversedWord}" in ${utterance.lang}`);
      };

      utterance.onstart = () => {
        console.log(`Speaking: "${reversedWord}" in ${utterance.lang}`);
      };

      speechSynthesis.cancel();
      speechSynthesis.speak(utterance);
    }

    function submitGuess() {
      if (buttonsBlocked) return;
      if (!gameState.isPlaying) return;

      const guess = gameState.currentGuess.toLowerCase().trim();
      const feedback = document.getElementById("feedback");

      if (normalizeWord(guess) === normalizeWord(gameState.currentWord)) {
        if (gameState.gameMode === "daily") {
          // Daily challenge mode - mark aim as hit or helped
          if (gameState.processedWords < gameState.dailyWords.length) {
            gameState.aims[gameState.processedWords] = gameState.helpRequested ? 'helped' : 'hit';
          }
          gameState.processedWords++;

          // Save progress
          saveGameProgress();

          // Record word stat
          gameState.dailyWordStats.push({
            word: gameState.currentWord,
            status: gameState.helpRequested ? 'helped' : 'correct',
            time: gameState.elapsedTime
          });

          gameState.currentWordIndex++;

          // Highlight word display green for correct answer
          gameState.displayState = 'correct';
          blockGameButtons();
          updateWordDisplay();

          setTimeout(() => {
            nextWord();
          }, 2000);
        } else {
          // Survival mode
          const wordLength = gameState.currentWord.length;
          // –ë–æ–Ω—É—Å –∑–∞ –±—ã—Å—Ç—Ä–æ–µ —É–≥–∞–¥—ã–≤–∞–Ω–∏–µ: 3x –µ—Å–ª–∏ –±–æ–ª—å—à–µ 30 —Å–µ–∫, –∏–Ω–∞—á–µ 2x
          const multiplier = gameState.timeLeft > 30 ? 3 : 2;
          const points = multiplier * wordLength;
          gameState.score += points;
          gameState.wordsGuessed++;

          // –ü–æ–≤—ã—à–∞–µ–º —É—Ä–æ–≤–µ–Ω—å –∫–∞–∂–¥—ã–µ 5 —É–≥–∞–¥–∞–Ω–Ω—ã—Ö —Å–ª–æ–≤
          gameState.level = Math.floor(gameState.wordsGuessed / 5) + 1;

          // Show points animation from Submit button
          showPointsAnimation('submit-btn', points);

          // Highlight word display green for correct answer
          gameState.displayState = 'correct';
          blockGameButtons();
          updateWordDisplay();

          clearInterval(gameState.timer);
          // Reset timer to 60 for next word
          gameState.timeLeft = 60;

          setTimeout(() => {
            nextWord();
          }, 2000);
        }
      } else {
        // Flash submit button and change text
        const submitBtn = document.querySelector('.submit-button');

        // Clear any existing timeout first
        if (submitBtn.wrongTimeout) {
          clearTimeout(submitBtn.wrongTimeout);
        }

        // Store original text only if it's not already "Wrong"
        if (!submitBtn.originalText || submitBtn.innerHTML === 'Wrong') {
          submitBtn.originalText = 'Submit';
        }

        submitBtn.innerHTML = 'Wrong';
        submitBtn.classList.add('wrong');

        submitBtn.wrongTimeout = setTimeout(() => {
          submitBtn.innerHTML = submitBtn.originalText;
          submitBtn.classList.remove('wrong');
          submitBtn.wrongTimeout = null;
        }, 800);

        // Don't reduce lives for wrong guesses
      }

      updateDisplay();
    }

    function requestHelp() {
      if (buttonsBlocked) return;
      if (gameState.gameMode !== "daily" || gameState.helpRequested) return;

      gameState.helpRequested = true;
      gameState.displayState = 'helped';
      updateWordDisplay();
      updateSkipButton();

      // Save progress when help is shown
      saveGameProgress();
    }

    function skipWord() {
      if (buttonsBlocked) return;
      if (gameState.gameMode === "daily" && !gameState.helpRequested) {
        // First click - show help
        requestHelp();
        return;
      }

      // Show the correct word
      gameState.currentGuess = gameState.currentWord;
      gameState.displayState = gameState.gameMode === 'daily' ? 'give-up' : 'skipped';
      blockGameButtons();
      updateWordDisplay();

      if (gameState.gameMode === "daily") {
        // Record skipped word stat
        gameState.dailyWordStats.push({
          word: gameState.currentWord,
          status: 'skipped',
          time: gameState.elapsedTime
        });

        // Mark as miss in aims
        if (gameState.processedWords < gameState.dailyWords.length) {
          gameState.aims[gameState.processedWords] = 'miss';
        }
        gameState.processedWords++;

        // Save progress
        saveGameProgress();

        // Daily challenge mode - only add to skipped if from main list, not if already skipped
        if (gameState.currentWordIndex < gameState.dailyWords.length) {
          gameState.skippedWords.push(gameState.currentWord);
          gameState.currentWordIndex++;
        } else {
          // This was a skipped word being processed - don't re-add it
          // Just mark it as processed by not adding back to skipped list
        }

        setTimeout(() => {
          nextWord();
        }, 2000);
      } else {
        // Survival mode
        // Reduce score by 1x –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –±—É–∫–≤, but don't go below 0
        const wordLength = gameState.currentWord.length;
        const points = -wordLength;
        const oldScore = gameState.score;
        gameState.score = Math.max(0, gameState.score - wordLength);

        // Show points animation from Skip button (only if score actually decreased)
        if (oldScore > gameState.score) {
          showPointsAnimation('skip-btn', points);
        }

        clearInterval(gameState.timer);

        // If less than 10 seconds, boost to 10 seconds
        if (gameState.timeLeft < 10) {
          gameState.timeLeft = 10;
        }

        setTimeout(() => {
          nextWord();
        }, 2000);
      }

      updateDisplay();
    }

    function updateSkipButton() {
      const skipBtn = document.getElementById('skip-btn');
      if (gameState.gameMode === "daily") {
        if (gameState.helpRequested) {
          skipBtn.textContent = 'Skip';
        } else {
          skipBtn.textContent = 'Help';
        }
      } else {
        skipBtn.textContent = 'Skip';
      }
    }

    let buttonsBlocked = false;
    let nextGameTimer = null;

    function blockGameButtons() {
      buttonsBlocked = true;
      // Enable buttons after 2 seconds (when word disappears)
      setTimeout(() => {
        buttonsBlocked = false;
      }, 2000);
    }

    function getTimeUntilNextGame() {
      const now = new Date();
      const tomorrow = new Date(now);
      tomorrow.setDate(tomorrow.getDate() + 1);
      tomorrow.setHours(0, 0, 0, 0);

      const diff = tomorrow.getTime() - now.getTime();
      const hours = Math.floor(diff / (1000 * 60 * 60));
      const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
      const seconds = Math.floor((diff % (1000 * 60)) / 1000);

      return { hours, minutes, seconds, diff };
    }

    function startNextGameTimer(element) {
      clearInterval(nextGameTimer);

      function updateTimer() {
        const { hours, minutes, seconds, diff } = getTimeUntilNextGame();

        // Check if timer has gone negative (past midnight)
        if (diff <= 0) {
          // New day has started, reload the state
          stopNextGameTimer();
          updateResultDisplay();
          return;
        }

        if (element) {
          element.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
      }

      updateTimer();
      nextGameTimer = setInterval(updateTimer, 1000);
    }

    function stopNextGameTimer() {
      clearInterval(nextGameTimer);
      nextGameTimer = null;
    }

    function enableGameButtons() {
      buttonsBlocked = false;
    }

    function createAimsHTML(aims) {
      return aims.map(aim => {
        let className = 'aim';
        let icon = '';

        switch (aim) {
          case 'hit':
            className += ' hit';
            icon = '<i class="fas fa-check"></i>';
            break;
          case 'helped':
            className += ' helped';
            icon = '<i class="fas fa-check"></i>';
            break;
          case 'miss':
            className += ' miss';
            icon = '<i class="fas fa-times"></i>';
            break;
          default:
            // empty - just the base aim class
            break;
        }

        return `<div class="${className}">${icon}</div>`;
      }).join('');
    }

    function getAimsEmoji(aims) {
      return aims.map(aim => {
        switch (aim) {
          case 'hit': return 'üü¢';
          case 'helped': return 'üü°';
          case 'miss': return 'üî¥';
          default: return '‚ö™';
        }
      }).join('');
    }


    function startTimer() {
      clearInterval(gameState.timer);
      gameState.timer = setInterval(() => {
        gameState.timeLeft--;
        updateDisplay();

        if (gameState.timeLeft <= 0) {
          gameState.lives--; // Reduce life for timeout
          clearInterval(gameState.timer);

          // Show correct answer in red
          gameState.currentGuess = gameState.currentWord;
          gameState.displayState = 'timeout';
          blockGameButtons();
          updateWordDisplay();

          // Reset timer to 60 for next word
          gameState.timeLeft = 60;
          updateDisplay();

          if (gameState.lives <= 0) {
            setTimeout(() => {
              endGame();
            }, 2000);
          } else {
            setTimeout(() => {
              nextWord();
            }, 2000);
          }
        }
      }, 1000);
    }

    function startDailyTimer() {
      clearInterval(gameState.timer);
      gameState.timer = setInterval(() => {
        gameState.elapsedTime++;
        updateDisplay();
      }, 1000);
    }

    function endDailyChallenge() {
      gameState.isPlaying = false;
      clearInterval(gameState.timer);
      speechSynthesis.cancel();

      // Mark remaining words as miss
      for (let i = gameState.currentWordIndex; i < gameState.dailyWords.length; i++) {
        if (gameState.aims[i] === 'empty') {
          gameState.aims[i] = 'miss';
        }
      }

      // Calculate completion stats
      const hitsCount = gameState.aims.filter(aim => aim === 'hit').length;
      const helpedCount = gameState.aims.filter(aim => aim === 'helped').length;
      const totalTime = gameState.elapsedTime;
      const today = new Date().toISOString().split('T')[0];

      // Save daily result with detailed stats
      if (!gameState.dailyResult[gameState.currentLanguage]) {
        gameState.dailyResult[gameState.currentLanguage] = {};
      }
      gameState.dailyResult[gameState.currentLanguage][today] = {
        hits: hitsCount + helpedCount, // Total successful
        time: totalTime,
        aims: [...gameState.aims], // Save the aims array
        detailed: {
          perfect: hitsCount,
          helped: helpedCount,
          words: gameState.dailyWordStats
        }
      };

      // Clear progress for completed game
      if (gameState.gameProgress &&
          gameState.gameProgress[gameState.currentLanguage] &&
          gameState.gameProgress[gameState.currentLanguage][today]) {
        delete gameState.gameProgress[gameState.currentLanguage][today];
      }

      saveSettings();

      // Show completion screen with detailed results
      showDailyResults(hitsCount, helpedCount, totalTime);
    }

    function showShareResultsModal(aims, totalTime) {
      const gameOverScreen = document.getElementById("game-over-screen");

      // Create detailed results HTML
      const minutes = Math.floor(totalTime / 60);
      const seconds = totalTime % 60;
      const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;

      gameOverScreen.innerHTML = `
        <h2>Share my score</h2>
        <div class="daily-results">
          <p style="margin: 0;"><i class="fas fa-globe"></i> ${(() => {
            const langCodes = { english: 'EN', russian: 'RU', german: 'DE', spanish: 'ES' };
            return langCodes[gameState.currentLanguage];
          })()} &nbsp;&nbsp; <i class="fas fa-clock"></i> ${timeStr}</p>
          <div style="display: flex; gap: 6px; justify-content: center; margin: 10px 0; transform: scale(0.67);">${createAimsHTML(aims)}</div>
        </div>

        <div class="share-buttons" style="margin: 10px 0; display: flex; gap: 10px; justify-content: center;">
          <button class="share-btn twitter" onclick="shareToTwitter()">ùïè</button>
          <button class="share-btn whatsapp" onclick="shareToWhatsApp()"><i class="fab fa-whatsapp"></i></button>
          <button class="share-btn telegram" onclick="shareToTelegram()"><i class="fab fa-telegram"></i></button>
          <button class="share-btn copy" onclick="copyScore()" title="Copy score"><i class="fas fa-copy"></i></button>
        </div>

        <button class="play-button" onclick="goHome()" style="margin-top: 10px;">Close</button>
      `;

      document.getElementById("start-screen").style.display = "none";
      document.getElementById("play-screen").style.display = "none";
      document.getElementById("game-over-screen").style.display = "block";
    }

    function showDailyResults(perfectHits, helpedHits, totalTime) {
      showShareResultsModal(gameState.aims, totalTime);
    }

    function endGame() {
      gameState.isPlaying = false;
      clearInterval(gameState.timer);
      speechSynthesis.cancel();

      // Disable submit button when game is over
      const submitBtn = document.getElementById('submit-btn');
      if (submitBtn) {
        submitBtn.disabled = true;
      }

      // Update high score if current score is higher
      if (gameState.score > gameState.highScore) {
        gameState.highScore = gameState.score;
      }

      // Save survival result
      const currentSurvivalScore = gameState.survivalResult[gameState.currentLanguage] || 0;
      if (gameState.score > currentSurvivalScore) {
        gameState.survivalResult[gameState.currentLanguage] = gameState.score;
      }
      saveSettings();

      document.getElementById("final-score").textContent = gameState.score;
      document.getElementById("best-score").textContent = gameState.highScore;

      updateDisplay();
      // Don't hide play screen, just show game over overlay
      document.getElementById("game-over-screen").style.display = "block";
    }

    function goHome() {
      // Stop current game
      gameState.isPlaying = false;
      clearInterval(gameState.timer);
      speechSynthesis.cancel();

      // Hide game elements, show home elements
      document.getElementById("home-stats").style.display = "flex";
      document.getElementById("game-stats").style.display = "none";

      document.getElementById("start-screen").style.display = "block";
      document.getElementById("play-screen").style.display = "none";
      document.getElementById("game-over-screen").style.display = "none";

      // Update result display
      updateResultDisplay();
    }

    function restartGame() {
      // Hide game over overlay first
      document.getElementById("game-over-screen").style.display = "none";

      // For daily challenge, go back to home instead of restarting if already completed today
      if (gameState.gameMode === 'daily') {
        const today = new Date().toISOString().split('T')[0];
        const dailyData = gameState.dailyResult[gameState.currentLanguage];
        const todayResult = dailyData && dailyData[today];

        if (todayResult) {
          goHome();
          return;
        }
      }

      startGame();
    }

    function updateDisplay() {
      const highScoreElement = document.getElementById("high-score");
      if (highScoreElement) {
        highScoreElement.textContent = gameState.highScore;
      }

      if (gameState.gameMode === "daily") {
        // Show daily challenge stats
        document.getElementById("survival-stats").style.display = "none";
        document.getElementById("daily-stats").style.display = "flex";

        // Show daily timer, hide survival timer
        document.getElementById("timer").style.display = "none";
        document.getElementById("daily-timer").style.display = "flex";

        // Update elapsed time
        const minutes = Math.floor(gameState.elapsedTime / 60);
        const seconds = gameState.elapsedTime % 60;
        document.getElementById("daily-timer-value").textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;


        updateAimsDisplay();
      } else {
        // Show survival stats
        document.getElementById("survival-stats").style.display = "flex";
        document.getElementById("daily-stats").style.display = "none";

        // Show survival timer, hide daily timer
        document.getElementById("timer").style.display = "flex";
        document.getElementById("daily-timer").style.display = "none";

        const scoreElement = document.getElementById("score");
        if (scoreElement) {
          scoreElement.textContent = gameState.score;
        }
        updateHeartsDisplay();
        updateLevelDisplay();

        // Update timer with color coding
        const timerElement = document.getElementById("timer");
        const timerValue = document.getElementById("timer-value");
        const timeLeft = Math.max(0, gameState.timeLeft); // Never show negative

        if (timerValue) {
          timerValue.textContent = timeLeft;
        }

        // Reset timer classes
        if (timerElement) {
          timerElement.className = "timer large-timer";

          // Add danger class when 10 seconds or less
          if (timeLeft <= 10 && timeLeft > 0) {
            timerElement.classList.add("danger");
          }
        }
      }
    }

    function updateLevelDisplay() {
      const levelNumber = document.getElementById("level-number");

      if (!levelNumber) return;

      levelNumber.textContent = gameState.level;
    }

    function updateHeartsDisplay() {
      const heartsContainer = document.getElementById("hearts-display");
      heartsContainer.innerHTML = "";

      const totalHearts = 3; // Always show 3 heart positions

      for (let i = 0; i < totalHearts; i++) {
        const heart = document.createElement("i");
        if (i < gameState.lives) {
          // Alive heart
          heart.className = "fas fa-heart";
          heart.style.color = "#e74c3c";
        } else {
          // Broken heart
          heart.className = "fas fa-heart-broken";
          heart.style.color = "#bdc3c7"; // Gray color for broken hearts
        }
        heart.style.marginRight = "3px";
        heartsContainer.appendChild(heart);
      }
    }

    function updateAimsDisplay() {
      const aimsContainer = document.getElementById("aims-display");
      aimsContainer.innerHTML = "";

      for (let i = 0; i < gameState.dailyWords.length; i++) {
        const aim = document.createElement("div");
        aim.className = "aim";

        if (gameState.aims[i] === 'hit') {
          aim.classList.add("hit");
          aim.innerHTML = '<i class="fas fa-check"></i>';
        } else if (gameState.aims[i] === 'helped') {
          aim.classList.add("helped");
          aim.innerHTML = '<i class="fas fa-check"></i>';
        } else if (gameState.aims[i] === 'miss') {
          aim.classList.add("miss");
          aim.innerHTML = '<i class="fas fa-times"></i>';
        }

        aimsContainer.appendChild(aim);
      }
    }

    function handleKeyPress(event) {
      if (event.key === "Enter") {
        submitGuess();
        refocusInput();
      }
    }

    function refocusInput() {
      setTimeout(() => {
        const hiddenInput = document.getElementById("hidden-input");
        if (hiddenInput && gameState.isPlaying) {
          hiddenInput.focus();
        }
      }, 50);
    }

    function shareToTwitter() {
      let text;
      if (gameState.gameMode === "daily") {
        // Get saved result for today
        const today = new Date().toISOString().split('T')[0];
        const dailyData = gameState.dailyResult[gameState.currentLanguage];
        const todayResult = dailyData && dailyData[today];

        if (todayResult) {
          const aims = getAimsEmoji(todayResult.aims);
          const minutes = Math.floor(todayResult.time / 60);
          const seconds = todayResult.time % 60;
          const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
          text = `My score today\n${gameState.currentLanguage.substring(0, 2).toUpperCase()} | ${timeStr} | ${aims}\n\nPlay here: ${window.location.href}`;
        } else {
          text = `My score today\n${gameState.currentLanguage.substring(0, 2).toUpperCase()}\n\nPlay here: ${window.location.href}`;
        }
      } else {
        text = `Just scored ${gameState.score} stars in ELDROW! My best: ${gameState.highScore} ‚≠ê\n\nPlay here: ${window.location.href}`;
      }
      const twitterUrl = `https://x.com/intent/tweet?text=${encodeURIComponent(text)}`;
      window.open(twitterUrl, '_blank');
    }


    function copyScore() {
      let text;
      if (gameState.gameMode === "daily") {
        // Get saved result for today
        const today = new Date().toISOString().split('T')[0];
        const dailyData = gameState.dailyResult[gameState.currentLanguage];
        const todayResult = dailyData && dailyData[today];

        if (todayResult) {
          const aims = getAimsEmoji(todayResult.aims);
          const minutes = Math.floor(todayResult.time / 60);
          const seconds = todayResult.time % 60;
          const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
          text = `My score today\n${gameState.currentLanguage.substring(0, 2).toUpperCase()} | ${timeStr} | ${aims}\n\nPlay here: ${window.location.href}`;
        } else {
          text = `My score today\n${gameState.currentLanguage.substring(0, 2).toUpperCase()}\n\nPlay here: ${window.location.href}`;
        }
      } else {
        text = `ELDROW Score: ${gameState.score} stars ‚≠ê\nBest: ${gameState.highScore} stars\n\nPlay: ${window.location.href}`;
      }

      if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(text).then(() => {
          showCopyFeedback();
        });
      } else {
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        showCopyFeedback();
      }
    }

    function showCopyFeedback() {
      const copyBtn = document.querySelector('.share-btn.copy');
      const originalIcon = copyBtn.innerHTML;
      copyBtn.innerHTML = '<i class="fas fa-check"></i>';

      setTimeout(() => {
        copyBtn.innerHTML = originalIcon;
      }, 2000);
    }

    function shareToWhatsApp() {
      let text;
      if (gameState.gameMode === "daily") {
        // Get saved result for today
        const today = new Date().toISOString().split('T')[0];
        const dailyData = gameState.dailyResult[gameState.currentLanguage];
        const todayResult = dailyData && dailyData[today];

        if (todayResult) {
          const aims = getAimsEmoji(todayResult.aims);
          const minutes = Math.floor(todayResult.time / 60);
          const seconds = todayResult.time % 60;
          const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
          text = `My score today\n${gameState.currentLanguage.substring(0, 2).toUpperCase()} | ${timeStr} | ${aims}\n\nPlay here: ${window.location.href}`;
        } else {
          text = `My score today\n${gameState.currentLanguage.substring(0, 2).toUpperCase()}\n\nPlay here: ${window.location.href}`;
        }
      } else {
        text = `ELDROW Score: ${gameState.score} stars ‚≠ê\nBest: ${gameState.highScore} stars\n\nPlay this reverse word game: ${window.location.href}`;
      }
      const whatsappUrl = `https://api.whatsapp.com/send/?text=${encodeURIComponent(text)}`;
      window.open(whatsappUrl, '_blank');
    }

    function shareToTelegram() {
      let text;
      if (gameState.gameMode === "daily") {
        // Get saved result for today
        const today = new Date().toISOString().split('T')[0];
        const dailyData = gameState.dailyResult[gameState.currentLanguage];
        const todayResult = dailyData && dailyData[today];

        if (todayResult) {
          const aims = getAimsEmoji(todayResult.aims);
          const minutes = Math.floor(todayResult.time / 60);
          const seconds = todayResult.time % 60;
          const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
          text = `My score today\n${gameState.currentLanguage.substring(0, 2).toUpperCase()} | ${timeStr} | ${aims}`;
        } else {
          text = `My score today\n${gameState.currentLanguage.substring(0, 2).toUpperCase()}`;
        }
      } else {
        text = `ELDROW Score: ${gameState.score} stars ‚≠ê\nBest: ${gameState.highScore} stars`;
      }
      const telegramUrl = `https://t.me/share/url?url=${encodeURIComponent(window.location.href)}&text=${encodeURIComponent(text)}`;
      window.open(telegramUrl, '_blank');
    }

    // Close popup when clicking outside
    document.addEventListener('click', (event) => {
      const popup = document.getElementById('language-popup');
      const langSelector = document.querySelector('.language-selector');

      if (popup && !langSelector.contains(event.target)) {
        popup.classList.remove('show');
      }
    });

    function initializeGameMode() {
      // Check URL hash to determine game mode
      const isSurvival = window.location.hash === '#survival';
      gameState.gameMode = isSurvival ? 'survival' : 'daily';

      console.log(`Initialized game mode: ${gameState.gameMode}`);
    }

    function updateResultDisplay() {
      const homeStats = document.getElementById('home-stats');
      const today = new Date().toISOString().split('T')[0];

      if (gameState.gameMode === 'daily') {
        if (!gameState.currentLanguage) {
          homeStats.innerHTML = '<div>Daily Challenge</div>';
          const startBtn = document.querySelector('.start-button');
          startBtn.disabled = false;
          startBtn.textContent = 'Start';
          startBtn.onclick = startGame;
          return;
        }
        // Daily challenge mode
        const dailyData = gameState.dailyResult[gameState.currentLanguage];
        const todayResult = dailyData && dailyData[today];

        if (todayResult) {
          // Show today's result and disable start button
          const minutes = Math.floor(todayResult.time / 60);
          const seconds = todayResult.time % 60;
          const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
          const aimsHTML = todayResult.aims ? createAimsHTML(todayResult.aims) : '';
          homeStats.innerHTML = `
            <div style="display: flex; align-items: center; gap: 10px; justify-content: center; margin-bottom: 8px;">
              <span style="font-weight: bold;">Today Result:</span>
              <div class="timer" style="margin: 0;">
                <i class="fas fa-clock"></i>
                <span>${timeStr}</span>
              </div>
            </div>
            <div style="display: flex; gap: 4px; justify-content: center; margin-bottom: 12px;">${aimsHTML}</div>
            <div style="display: flex; align-items: center; justify-content: center; gap: 6px; font-size: 14px; opacity: 0.8;">
              <span>Next game in</span>
              <span id="next-game-timer" >00:00:00</span>
            </div>
          `;
          // Hide game description when result is shown
          document.getElementById('game-description').style.display = 'none';
          const startBtn = document.querySelector('.start-button');
          startBtn.disabled = false;
          startBtn.textContent = 'Share';
          startBtn.onclick = () => showShareResultsModal(todayResult.aims, todayResult.time);

          // Start the next game timer
          const timerElement = document.getElementById('next-game-timer');
          if (timerElement) {
            startNextGameTimer(timerElement);
          }
        } else {
          // No result for today - check for unfinished game
          homeStats.innerHTML = '<div>Daily Challenge</div>';
          // Show game description when no result
          document.getElementById('game-description').style.display = 'block';
          const startBtn = document.querySelector('.start-button');
          startBtn.disabled = false;

          // Stop next game timer when no results are shown
          stopNextGameTimer();

          if (hasUnfinishedGame()) {
            startBtn.textContent = 'Continue';
            startBtn.onclick = continueGame;
          } else {
            startBtn.textContent = 'Start';
            startBtn.onclick = startGame;
          }
        }
      } else {
        // Survival mode - stop next game timer
        stopNextGameTimer();

        if (!gameState.currentLanguage) {
          homeStats.innerHTML = '<div>Survival Mode</div>';
          document.getElementById('game-description').style.display = 'block';
          const startBtn = document.querySelector('.start-button');
          startBtn.disabled = false;
          startBtn.textContent = 'Start';
          startBtn.onclick = startGame;
        } else {
          const survivalScore = gameState.survivalResult[gameState.currentLanguage] || 0;
          if (survivalScore > 0) {
            homeStats.innerHTML = `
              <div>Survival Mode</div>
              <div>Best Result: ${survivalScore} <i class="fas fa-star"></i></div>
            `;
            document.getElementById('game-description').style.display = 'none';
          } else {
            homeStats.innerHTML = '<div>Survival Mode</div>';
            document.getElementById('game-description').style.display = 'block';
          }
        }

        if (gameState.currentLanguage) {
          const startBtn = document.querySelector('.start-button');
          startBtn.disabled = false;
          startBtn.textContent = 'Start';
          startBtn.onclick = startGame;
        }
      }
    }

    // Initialize the game
    window.addEventListener('DOMContentLoaded', () => {
      initializeGameMode(); // Determine game mode from URL
      loadSettings(); // Load saved settings first
      updateLanguageDisplay(); // Update display based on current state
      updateResultDisplay(); // Update result display
      // Only load language if user has previously selected one
      if (gameState.currentLanguage) {
        changeLanguage(); // Load language (will use saved language)
      }
    });

    // Listen for hash changes
    window.addEventListener('hashchange', () => {
      initializeGameMode();
      updateResultDisplay();
    });

    window.addEventListener('beforeunload', () => {
      speechSynthesis.cancel();
      clearInterval(gameState.timer);
      stopNextGameTimer();
    });
  </script>
</body>
</html>